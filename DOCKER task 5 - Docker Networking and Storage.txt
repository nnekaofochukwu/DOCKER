
1. Explore Docker Networking:

Step 1: Create the Custom Docker Network

First, create the custom Docker network food-bridge-network with your desired subnet and gateway addresses.

Copy code
docker network create \
  --driver bridge \
  --subnet 192.168.50.0/24 \
  --gateway 192.168.50.1 \
  food-bridge-network

--subnet 192.168.50.0/24: Specifies the IP address range for the network (192.168.50.0 to 192.168.50.255).

--gateway 192.168.50.1: Defines the gateway for the network (192.168.50.1).

food-bridge-network: The name of the custom network.

Step 2: Run the Docker Container on the Custom Network
Next, run a Docker container named food-container and connect it to the food-bridge-network with a specific IP address within the defined subnet.

Copy code
docker run -d \
  --name food-container \
  --network food-bridge-network \
  --ip 192.168.50.10 \
  nginx

-d: Runs the container in detached mode.

--name food-container: Assigns the name food-container to the container.

--network food-bridge-network: Connects the container to the food-bridge-network network.

--ip 192.168.50.10: Assigns the specific IP address 192.168.50.10 to the container within the network.

nginx: The Docker image to use (Nginx in this case).

Complete Commands
Combining both steps, here are the complete commands:

Create the custom Docker network:

Copy code
docker network create --driver bridge --subnet 192.168.50.0/24 --gateway 192.168.50.1 food-bridge-network

Run the Docker container on the custom network:

Copy code
docker run -d --name food-container --network food-bridge-network --ip 192.168.50.10 nginx

Verification
To verify the setup, you can use the following commands:

List all Docker networks to verify food-bridge-network exists:

Copy code
docker network ls

Inspect the food-bridge-network to check its details:

Copy code
docker network inspect food-bridge-network

Check the running container food-container details:

Copy code
docker ps

docker inspect food-container

These steps will set up a Docker container named food-container connected to the food-bridge-network with the specified subnet (192.168.50.0/24) and gateway (192.168.50.1). Adjust the IP addresses (--ip) and other parameters as needed for your specific requirements.


2. Persistent Storage Solutions in Docker

Concept of Persistent Storage

In Docker, persistent storage refers to mechanisms that allow data generated by containers to persist beyond the container's lifecycle. 
By default, Docker containers store data within the writable layer of the container, which is ephemeral; once the container is removed, the data is lost. 
Persistent storage ensures that data remains available even after the container is stopped or deleted, enabling stateful applications and data retention across container restarts and migrations.

Volumes

Volumes are the preferred mechanism for persistent storage in Docker. 
Managed by Docker, volumes are stored outside the container's filesystem, typically in a designated directory on the host. 
They are created and managed using Docker commands and can be easily shared and reused by multiple containers. 
Volumes provide better performance and flexibility, especially when dealing with large amounts of data or sharing data between containers. 
They are also more portable, as they are not tied to specific directories on the host system.

ou can create a volume explicitly using the docker volume create command, or Docker can create a volume during container or service creation.

When you create a volume, it's stored within a directory on the Docker host. When you mount the volume into a container, this directory 
is what's mounted into the container. This is similar to the way that bind mounts work, except that volumes are managed by Docker and are isolated 
from the core functionality of the host machine.

A given volume can be mounted into multiple containers simultaneously. 
When no running container is using a volume, the volume is still available to Docker and isn't removed automatically. 
You can remove unused volumes using docker volume prune.

When you mount a volume, it may be named or anonymous. Anonymous volumes are given a random name that's guaranteed to be unique within a given Docker host. 
Just like named volumes, anonymous volumes persist even if you remove the container that uses them, except if you use the --rm flag when creating the container, 
in which case the anonymous volume is destroyed. See Remove anonymous volumes. If you create multiple containers after each other that use anonymous volumes, 
each container creates its own volume. 
Anonymous volumes aren't reused or shared between containers automatically. To share an anonymous volume between two or more containers, 
you must mount the anonymous volume using the random volume ID.

Volumes also support the use of volume drivers, which allow you to store your data on remote hosts or cloud providers, among other possibilities.



Bind Mounts

Bind mounts allow containers to access specific directories or files on the host filesystem. 
When using bind mounts, you specify an exact path on the host that is mounted into the container. 
This approach is straightforward and provides direct access to the host filesystem, which can be useful for development and debugging. 
However, bind mounts are less portable and can be less secure and harder to manage than volumes, as they rely on the host's directory structure.
Bind mounts have limited functionality compared to volumes. When you use a bind mount, a file or directory on the host machine is mounted into a container. The file or directory is referenced by its full path on the host machine. The file or directory doesn't need to exist on the Docker host already. It is created on demand if it doesn't yet exist. Bind mounts are fast, but they rely on the host machine's filesystem having a specific directory structure available. If you are developing new Docker applications, consider using named volumes instead. You can't use Docker CLI commands to directly manage bind mounts.

Important

Bind mounts allow write access to files on the host by default.

One side effect of using bind mounts is that you can change the host filesystem via processes running in a container, 
including creating, modifying, or deleting important system files or directories. 
This is a powerful ability which can have security implications, including impacting non-Docker processes on the host system.






The Docker run command used to create a docker container with a mounted volume and 
verify that data persists after container termination and restart -


1. Create a Named Volume: You can create a named volume using the docker volume create command.

Copy code
docker volume create my-custom-volume

then cd into your app

copy code
docker build -t my-app .

2. Use the Named Volume in Your Docker Container: When running your Docker container, you can specify the named volume using the -v flag.

Copy code
docker run -d -p 3000:3000 -v my-custom-volume:/app my-app

Now, you have a Docker container running with a named volume my-custom-volume mounted to /app in the container.
 This allows you to manage and reference the volume by name easily.
